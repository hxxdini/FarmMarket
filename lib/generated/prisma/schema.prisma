generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model AdminActionLog {
  id         String   @id
  adminId    String
  action     String
  targetType String
  targetId   String
  details    Json
  timestamp  DateTime @default(now())
  User       User     @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId, timestamp])
  @@index([targetType, targetId])
  @@index([timestamp])
}

model AlertNotification {
  id          String      @id
  alertId     String
  userId      String
  title       String
  message     String
  alertType   AlertType
  cropType    String
  location    String
  oldPrice    Float?
  newPrice    Float?
  priceChange Float?
  status      AlertStatus @default(PENDING)
  sentAt      DateTime?
  readAt      DateTime?
  dismissedAt DateTime?
  createdAt   DateTime    @default(now())
  PriceAlert  PriceAlert  @relation(fields: [alertId], references: [id], onDelete: Cascade)
  User        User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([alertId, createdAt])
  @@index([cropType, location, createdAt])
  @@index([userId, status])
}

model Conversation {
  id                                           String          @id
  user1Id                                      String
  user2Id                                      String
  listingId                                    String?
  title                                        String?
  lastMessageId                                String?         @unique
  lastMessageAt                                DateTime?
  isArchived                                   Boolean         @default(false)
  createdAt                                    DateTime        @default(now())
  updatedAt                                    DateTime
  Message_Conversation_lastMessageIdToMessage  Message?        @relation("Conversation_lastMessageIdToMessage", fields: [lastMessageId], references: [id])
  ProductListing                               ProductListing? @relation(fields: [listingId], references: [id])
  User_Conversation_user1IdToUser              User            @relation("Conversation_user1IdToUser", fields: [user1Id], references: [id], onDelete: Cascade)
  User_Conversation_user2IdToUser              User            @relation("Conversation_user2IdToUser", fields: [user2Id], references: [id], onDelete: Cascade)
  Message_Message_conversationIdToConversation Message[]       @relation("Message_conversationIdToConversation")

  @@unique([user1Id, user2Id, listingId])
  @@index([listingId])
  @@index([user1Id, updatedAt])
  @@index([user2Id, updatedAt])
}

model MarketPrice {
  id                                 String       @id
  cropType                           String
  pricePerUnit                       Float
  unit                               String
  quality                            PriceQuality
  location                           String
  source                             PriceSource
  status                             PriceStatus  @default(PENDING)
  submittedBy                        String
  reviewedBy                         String?
  reviewNotes                        String?
  reviewDate                         DateTime?
  effectiveDate                      DateTime     @default(now())
  expiryDate                         DateTime?
  isVerified                         Boolean      @default(false)
  verificationScore                  Float        @default(0.0)
  marketTrend                        String?
  regionalAverage                    Float?
  priceChange                        Float?
  createdAt                          DateTime     @default(now())
  updatedAt                          DateTime
  User_MarketPrice_reviewedByToUser  User?        @relation("MarketPrice_reviewedByToUser", fields: [reviewedBy], references: [id])
  User_MarketPrice_submittedByToUser User         @relation("MarketPrice_submittedByToUser", fields: [submittedBy], references: [id], onDelete: Cascade)

  @@index([cropType, location, effectiveDate])
  @@index([effectiveDate, expiryDate])
  @@index([location, cropType, quality])
  @@index([pricePerUnit, cropType, location])
  @@index([reviewedBy, reviewDate])
  @@index([status, effectiveDate])
  @@index([submittedBy, createdAt])
}

model Message {
  id                                                String        @id
  conversationId                                    String
  senderId                                          String
  receiverId                                        String
  content                                           String
  messageType                                       MessageType   @default(TEXT)
  attachmentUrl                                     String?
  attachmentType                                    String?
  status                                            MessageStatus @default(SENT)
  readAt                                            DateTime?
  deliveredAt                                       DateTime?
  editedAt                                          DateTime?
  isEdited                                          Boolean       @default(false)
  replyToId                                         String?
  createdAt                                         DateTime      @default(now())
  updatedAt                                         DateTime
  Conversation_Conversation_lastMessageIdToMessage  Conversation? @relation("Conversation_lastMessageIdToMessage")
  Conversation_Message_conversationIdToConversation Conversation  @relation("Message_conversationIdToConversation", fields: [conversationId], references: [id], onDelete: Cascade)
  User_Message_receiverIdToUser                     User          @relation("Message_receiverIdToUser", fields: [receiverId], references: [id], onDelete: Cascade)
  Message                                           Message?      @relation("MessageToMessage", fields: [replyToId], references: [id])
  other_Message                                     Message[]     @relation("MessageToMessage")
  User_Message_senderIdToUser                       User          @relation("Message_senderIdToUser", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
  @@index([receiverId, status])
  @@index([senderId, createdAt])
}

model Permission {
  id          String  @id
  name        String  @unique
  description String?
  Role        Role[]
  User        User[]
}

model PriceAlert {
  id                String              @id
  userId            String
  cropType          String
  location          String
  quality           PriceQuality?
  alertType         AlertType
  frequency         AlertFrequency      @default(DAILY)
  threshold         Float
  isActive          Boolean             @default(true)
  lastTriggered     DateTime?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime
  AlertNotification AlertNotification[]
  User              User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, cropType, location, quality, alertType])
  @@index([cropType, location, alertType])
  @@index([userId, isActive])
}

model ProductImage {
  id             String         @id
  url            String
  altText        String?
  order          Int
  isPrimary      Boolean        @default(false)
  listingId      String
  createdAt      DateTime       @default(now())
  ProductListing ProductListing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@index([listingId, order])
}

model ProductListing {
  id             String         @id
  cropType       String
  quantity       Float
  unit           String
  pricePerUnit   Float
  quality        String
  location       String
  description    String?
  harvestDate    DateTime?
  availableUntil DateTime?
  status         ListingStatus  @default(ACTIVE)
  farmerId       String
  createdAt      DateTime       @default(now())
  updatedAt      DateTime
  Conversation   Conversation[]
  ProductImage   ProductImage[]
  User           User           @relation(fields: [farmerId], references: [id], onDelete: Cascade)
  Review         Review[]

  @@index([cropType, location])
  @@index([farmerId])
  @@index([status, createdAt])
}

model Review {
  id                           String          @id
  reviewerId                   String
  reviewedId                   String
  listingId                    String?
  rating                       Int
  title                        String?
  comment                      String?
  reviewType                   ReviewType      @default(TRANSACTION)
  isVerified                   Boolean         @default(false)
  isPublic                     Boolean         @default(true)
  helpfulCount                 Int             @default(0)
  isModerated                  Boolean         @default(false)
  moderatedAt                  DateTime?
  moderationReason             String?
  createdAt                    DateTime        @default(now())
  updatedAt                    DateTime
  ProductListing               ProductListing? @relation(fields: [listingId], references: [id])
  User_Review_reviewedIdToUser User            @relation("Review_reviewedIdToUser", fields: [reviewedId], references: [id], onDelete: Cascade)
  User_Review_reviewerIdToUser User            @relation("Review_reviewerIdToUser", fields: [reviewerId], references: [id], onDelete: Cascade)

  @@unique([reviewerId, reviewedId, listingId])
  @@index([listingId, rating])
  @@index([reviewedId, createdAt])
  @@index([reviewedId, rating])
  @@index([reviewerId, createdAt])
}

model Role {
  id         String       @id
  name       String       @unique
  User       User[]
  Permission Permission[]
}

model Session {
  id        String   @id
  userId    String
  token     String   @unique
  createdAt DateTime @default(now())
  expiresAt DateTime
  User      User     @relation(fields: [userId], references: [id])
}

model User {
  id                                         String              @id
  phone                                      String?             @unique
  name                                       String?
  location                                   String?
  roleId                                     String
  createdAt                                  DateTime            @default(now())
  updatedAt                                  DateTime
  email                                      String              @unique
  password                                   String
  avatar                                     String?
  billingAddress                             String?
  bio                                        String?
  dateOfBirth                                DateTime?
  emailNotifications                         Boolean             @default(true)
  gender                                     String?
  isEmailVerified                            Boolean             @default(false)
  isPhoneVerified                            Boolean             @default(false)
  lastLoginAt                                DateTime?
  loginCount                                 Int                 @default(0)
  marketingEmails                            Boolean             @default(false)
  preferredLanguage                          String              @default("en")
  pushNotifications                          Boolean             @default(true)
  smsNotifications                           Boolean             @default(true)
  subscriptionEndsAt                         DateTime?
  subscriptionPlan                           String              @default("free")
  subscriptionStatus                         String              @default("active")
  taxId                                      String?
  timezone                                   String              @default("UTC")
  twoFactorEnabled                           Boolean             @default(false)
  status                                     UserStatus          @default(ACTIVE)
  AdminActionLog                             AdminActionLog[]
  AlertNotification                          AlertNotification[]
  Conversation_Conversation_user1IdToUser    Conversation[]      @relation("Conversation_user1IdToUser")
  Conversation_Conversation_user2IdToUser    Conversation[]      @relation("Conversation_user2IdToUser")
  MarketPrice_MarketPrice_reviewedByToUser   MarketPrice[]       @relation("MarketPrice_reviewedByToUser")
  MarketPrice_MarketPrice_submittedByToUser  MarketPrice[]       @relation("MarketPrice_submittedByToUser")
  Message_Message_receiverIdToUser           Message[]           @relation("Message_receiverIdToUser")
  Message_Message_senderIdToUser             Message[]           @relation("Message_senderIdToUser")
  PriceAlert                                 PriceAlert[]
  ProductListing                             ProductListing[]
  Review_Review_reviewedIdToUser             Review[]            @relation("Review_reviewedIdToUser")
  Review_Review_reviewerIdToUser             Review[]            @relation("Review_reviewerIdToUser")
  Session                                    Session[]
  Role                                       Role                @relation(fields: [roleId], references: [id])
  Permission                                 Permission[]
  ExpertProfile                              ExpertProfile?
  CommunityPost_CommunityPost_authorToUser   CommunityPost[]     @relation("CommunityPost_authorToUser")
  CommunityReply_CommunityReply_authorToUser CommunityReply[]    @relation("CommunityReply_authorToUser")
  CommunityPostLike_userToUser               CommunityPostLike[] @relation("CommunityPostLike_userToUser")
}

model CommunityPost {
  id           String              @id
  authorId     String
  title        String
  content      String
  type         CommunityPostType   @default(QUESTION)
  category     String
  crop         String
  location     String?
  likes        Int                 @default(0)
  repliesCount Int                 @default(0)
  status       CommunityPostStatus @default(PENDING)
  createdAt    DateTime            @default(now())
  updatedAt    DateTime
  author       User                @relation("CommunityPost_authorToUser", fields: [authorId], references: [id], onDelete: Cascade)
  replies      CommunityReply[]
  likesList    CommunityPostLike[] @relation("CommunityPostLike_postToCommunityPost")

  @@index([type, status, createdAt])
  @@index([crop, location, createdAt])
  @@index([category, createdAt])
  @@index([authorId, createdAt])
}

model CommunityReply {
  id        String        @id
  postId    String
  authorId  String
  content   String
  isExpert  Boolean       @default(false)
  createdAt DateTime      @default(now())
  updatedAt DateTime
  post      CommunityPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  author    User          @relation("CommunityReply_authorToUser", fields: [authorId], references: [id], onDelete: Cascade)

  @@index([postId, createdAt])
  @@index([authorId, createdAt])
}

model CommunityPostLike {
  userId    String
  postId    String
  createdAt DateTime      @default(now())
  user      User          @relation("CommunityPostLike_userToUser", fields: [userId], references: [id], onDelete: Cascade)
  post      CommunityPost @relation("CommunityPostLike_postToCommunityPost", fields: [postId], references: [id], onDelete: Cascade)

  @@id([userId, postId])
  @@index([postId])
  @@index([userId])
}

model ExpertProfile {
  id             String     @id
  userId         String     @unique
  type           ExpertType @default(EXPERT)
  title          String?
  specialization String?
  location       String?
  rating         Float      @default(0)
  responses      Int        @default(0)
  isVerified     Boolean    @default(false)
  createdAt      DateTime   @default(now())
  updatedAt      DateTime
  user           User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([type, isVerified])
}

enum CommunityPostType {
  QUESTION
  ADVICE
  ALERT
  SUCCESS
}

enum CommunityPostStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ExpertType {
  EXPERT
  EXTENSION_OFFICER
}

enum AlertFrequency {
  IMMEDIATE
  DAILY
  WEEKLY
  MONTHLY
}

enum AlertStatus {
  PENDING
  SENT
  READ
  DISMISSED
}

enum AlertType {
  PRICE_INCREASE
  PRICE_DECREASE
  PRICE_VOLATILITY
  REGIONAL_DIFFERENCE
  QUALITY_OPPORTUNITY
  SEASONAL_TREND
}

enum ListingStatus {
  ACTIVE
  PENDING
  SOLD
  EXPIRED
  CANCELLED
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
  FAILED
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM
  OFFER
}

enum PriceQuality {
  PREMIUM
  STANDARD
  ECONOMY
}

enum PriceSource {
  FARMER_SUBMISSION
  EXTENSION_OFFICER
  MARKET_SURVEY
  GOVERNMENT_DATA
  THIRD_PARTY
}

enum PriceStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

enum ReviewType {
  TRANSACTION
  PRODUCT
  SERVICE
  COMMUNICATION
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  PENDING
}
